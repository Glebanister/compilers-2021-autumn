-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

var operatorPriority = {
  [Left, {"!!"}],
  [Left, {"&&"}],
  [Nona, {"==", "!=", "<=", "<", ">=", ">"}],
  [Left, {"+", "-"}],
  [Left, {"*", "/", "%"}]
};

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun mkOps (priority) {
  fun mkBinop (l, op, r) {
    Binop (op, l, r)
  }

  map (fun ([lnr, lops]) {
    [lnr, map (fun (op) { [s (op), mkBinop] }, lops)]
  } , priority)
}

-- Primary expression
var primary = 
      memo $ eta syntax (
          x=decimal { Const (stringInt (x)) } 
        | x=lident  { Var (x) }               
        | inbr[tkParenLeft, exp, tkParenRight ]
      ),
    exp = memo $ eta (expr (mkOps (operatorPriority), primary));

var ifEnd =
      memo $ eta syntax (
          kElse s=stmt { s }
        | kElif e=exp kThen st=stmt sf=ifEnd { If (e, st, sf) }
        | kElif e=exp kThen s=stmt { If (e, s, Skip) }
      ),
    stmtImpl = 
      memo $ eta syntax (
          l=lident tkAssignment e=exp { Assn (l, e) }
        | kSkip { Skip }
        | kRead i=inbr[tkParenLeft, lident, tkParenRight] { Read (i) }
        | kWrite i=inbr[tkParenLeft, exp, tkParenRight] { Write (i) }
        | kIf e=exp kThen st=stmt kFi { If (e, st, Skip) }
        | kIf e=exp kThen st=stmt sf=ifEnd kFi { If (e, st, sf) }
        | kWhile e=exp kDo s=stmt kOd { While (e, s) }
        | kDo s=stmt kWhile e=exp kOd { DoWhile (s, e) }
        | kFor stIni=stmt s [","] e=exp s [","] stStep=stmt
            kDo stCond=stmt kOd { Seq (stIni, While (e, Seq (stCond, stStep))) }
      ),
    stmt = 
      memo $ eta syntax (
          stmtImpl
        | l=stmtImpl s [";"] r=stmt { Seq (l, r) }
      );

-- Public top-level parser
public parse = stmt;
