-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"

var operatorsPriority = {
    [Left, {"!!"}],
    [Left, {"&&"}],
    [Nona, {"==", "!=", "<=", "<", ">=", ">"}],
    [Left, {"+", "-"}],
    [Left, {"*", "/", "%"}]
  };

fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun createBinaryOperators (priority) {
  fun createSingleBinop (l, op, r) {
    Binop (op, l, r)
  }

  map (fun ([assoc, operators]) {
    [
      assoc,
      map (
        fun (op) { [s (op), createSingleBinop] },
        operators
      )
    ]
  } , priority)
}

fun parens (exp) {
  inbr (parenLeft, exp, parenRight)
}

-- Primary expression
var primary = 
  memo $ eta syntax (
    x=decimal { Const (stringInt (x)) }
  | x=lident  { Var (x) }
  | parens[exp]
),
exp = memo $ eta (
  expr (
    createBinaryOperators (operatorsPriority),
    primary
  )
);

-- Statement
var stmt =
    memo $ eta syntax (
    varName = lident assignment asExpr = exp { Assn (varName, asExpr) }
  | first = stmt semicolon second = stmt end { Seq (first, second) }
  | kSkip { Skip }
  | kRead i = parens[lident] { Read (i) }
  | kWrite i = parens[exp] { Write (i) }
);

-- Public top-level parser
public parse = stmt;
